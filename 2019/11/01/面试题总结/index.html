<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Java笔记" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.3',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="title:  Java基础 1、JDK和JRE有什么区别​    JDK：java开发工具包，提供了java的开发环境和运行环境。​    JRE：java运行环境，为java的运行提供了所需环境​    JDK包含JRE、编译java源码的编译器javac和java程序调试和分析的工具。​    如果只是运行java程序，安装JRE就可以了，需要编写Java程序，需要安装JDK。 2、==和e">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;01&#x2F;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93&#x2F;index.html">
<meta property="og:site_name" content="Java笔记">
<meta property="og:description" content="title:  Java基础 1、JDK和JRE有什么区别​    JDK：java开发工具包，提供了java的开发环境和运行环境。​    JRE：java运行环境，为java的运行提供了所需环境​    JDK包含JRE、编译java源码的编译器javac和java程序调试和分析的工具。​    如果只是运行java程序，安装JRE就可以了，需要编写Java程序，需要安装JDK。 2、==和e">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-01T11:10:21.236Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/11/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>面试题总结 | Java笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Java笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mj.jpg">
      <meta itemprop="name" content="老寒腿青年">
      <meta itemprop="description" content="莫向外求">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Java笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-01 18:58:02 / Modified: 19:10:21" itemprop="dateCreated datePublished" datetime="2019-11-01T18:58:02+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>title:  Java基础</p>
<h3 id="1、JDK和JRE有什么区别"><a href="#1、JDK和JRE有什么区别" class="headerlink" title="1、JDK和JRE有什么区别"></a>1、JDK和JRE有什么区别</h3><p>​    JDK：java开发工具包，提供了java的开发环境和运行环境。<br>​    JRE：java运行环境，为java的运行提供了所需环境<br>​    JDK包含JRE、编译java源码的编译器javac和java程序调试和分析的工具。<br>​    如果只是运行java程序，安装JRE就可以了，需要编写Java程序，需要安装JDK。</p>
<h3 id="2、-和equals的区别是什么"><a href="#2、-和equals的区别是什么" class="headerlink" title="2、==和equals的区别是什么"></a>2、==和equals的区别是什么</h3><p>​    ==：<br>​        基本类型：比较值是否相同；<br>​        引用类型：比较地址值是否相同；<br>​        String x = “string”;<br>​        String y = “string”;<br>​        String z = new String(“string”);<br>​        System.out.println(x==y); // true<br>​        System.out.println(x==z); // false<br>​        System.out.println(x.equals(y)); // true<br>​        System.out.println(x.equals(z)); // true<br>​    equals：<br>​        Object类中equals本质是==，<br>​        public boolean equals(Object obj) {<br>​            return (this == obj);<br>​        }<br>​        String和Integer等重写equals方法，此时比较值是否相同</p>
<h3 id="3、hashcode和equal"><a href="#3、hashcode和equal" class="headerlink" title="3、hashcode和equal"></a>3、hashcode和equal</h3><p>​    两个对象的hashcode相同，equals不一定为true，<br>​    两个对象的equals为true，hashcode一定相同</p>
<h3 id="4、final关键字"><a href="#4、final关键字" class="headerlink" title="4、final关键字"></a>4、final关键字</h3><p>​    final修饰的类叫最终类，该类不能被继承<br>​    final修饰的方法不能被重写<br>​    final修饰的变量叫常量<br>​        final修饰基本类型的局部变量，基本类型的值不能发生改变<br>​        final修饰引用类型的局部变量，引用类型的地址值不能发生改变，但是对象的堆内存的值可以改变。<br>​        final StringBuffer a = new StringBuffer(“a”);<br>​        a = new StringBuffer(“”);编译报错<br>​        a.append(“b”);编译成功</p>
<h3 id="5、一个“-java”源文件是否可以包括多个类（不是内部类）？有什么限制？"><a href="#5、一个“-java”源文件是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="5、一个“.java”源文件是否可以包括多个类（不是内部类）？有什么限制？"></a>5、一个“.java”源文件是否可以包括多个类（不是内部类）？有什么限制？</h3><p>​    可以有多个类，但是只能有一个public的类，并且public的类名必须与文件名一致</p>
<a id="more"></a>
<h3 id="6、-amp-与-amp-amp-的区别"><a href="#6、-amp-与-amp-amp-的区别" class="headerlink" title="6、&amp;与&amp;&amp;的区别"></a>6、&amp;与&amp;&amp;的区别</h3><p>​    &amp;是逻辑与运算符和位运算符，只有当两边表达式都为true，运算结果才为true<br>​    &amp;&amp;是逻辑与运算符，但是具有短路效果，只要第一个表达式为false，则不再计算第二个表达式<br>​    if(str!=null&amp;&amp;!str.equals(“”))，str为null时，后面的不会执行，不会出现NullPointerException，反之，&amp;会报错。</p>
<h3 id="7、在Java中如何跳出当前的多重嵌套循环？"><a href="#7、在Java中如何跳出当前的多重嵌套循环？" class="headerlink" title="7、在Java中如何跳出当前的多重嵌套循环？"></a>7、在Java中如何跳出当前的多重嵌套循环？</h3><p>​    在外层的循环语句前定义一个标号，然后在内层循环体的代码中使用带有标号break语句，即可跳出外层循环。</p>
<h3 id="8、switch语句可以作用在byte、short、char、int、枚举、String"><a href="#8、switch语句可以作用在byte、short、char、int、枚举、String" class="headerlink" title="8、switch语句可以作用在byte、short、char、int、枚举、String"></a>8、switch语句可以作用在byte、short、char、int、枚举、String</h3><h3 id="9、-运算符，java编译器会对它进行类型转换"><a href="#9、-运算符，java编译器会对它进行类型转换" class="headerlink" title="9、+=运算符，java编译器会对它进行类型转换"></a>9、+=运算符，java编译器会对它进行类型转换</h3><p>​    short s1=1;<br>​    s1=s1+1;(错)<br>​    s1 +=1;(对)</p>
<h3 id="10、char类型可以存储一个中文汉字"><a href="#10、char类型可以存储一个中文汉字" class="headerlink" title="10、char类型可以存储一个中文汉字"></a>10、char类型可以存储一个中文汉字</h3><p>​    因为java使用的编码Unicode，char类型是存储Unicode编码的字符，Unicode编码中有汉字字符，所以可以存储，一个汉字占两个字节（UTF-8中一个汉字占三个字节）</p>
<h3 id="11、静态变量和实例变量的区别"><a href="#11、静态变量和实例变量的区别" class="headerlink" title="11、静态变量和实例变量的区别"></a>11、静态变量和实例变量的区别</h3><p>​    静态变量：<br>​        被static关键字修饰<br>​        属于类<br>​        加载类的字节码，静态变量就会别分配空间<br>​        可以直接使用类名调用</p>
<h3 id="12、面向对象的三大特点"><a href="#12、面向对象的三大特点" class="headerlink" title="12、面向对象的三大特点"></a>12、面向对象的三大特点</h3><p>​    封装<br>​        隐藏复杂过程，暴露简单操作<br>​    继承<br>​        提高代码的重用性和拓展性<br>​        是多态的前提<br>​    多态<br>​        是父类或者接口的引用变量指向子类或者具体实现类的实例对象，在运行是进行动态绑定<br>​        多态的前提：继承<br>​        多态的体现：向上转型<br>​        多态的限制：向上转型时，子类独有的属性和方法无法使用<br>​        多态的作用：提高代码的拓展性<br>​        多态的机制：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行时间才动态绑定，就是引用变量所指向的具体实例对象的方法。</p>
<h3 id="13、clone的相关知识点"><a href="#13、clone的相关知识点" class="headerlink" title="13、clone的相关知识点"></a>13、clone的相关知识点</h3><p>​    new一个对象的过程：<br>​        new是一个操作符，作用是分配内存，是根据new后面对象的类型来分配内存，之后调用构造函数，来填充对象的域，也叫对象的初始化<br>​        clone分配的内存和原对象相同，再用原对象中各个域填充新对象的域，clone返回之后，新对象被创建<br>​        clone是复制对象；复制对象对象的地址值不同，复制引用对象的地址不同<br>​        clone是浅拷贝；浅拷贝对象字段的字符串对象是同一个，只是把字符串对象的引用拷贝给新对象的字段。深拷贝字符串对象不是同一个，是创建一个新的相同的字符串对象，将这个新字符串对象赋给新对象的字段，要实现深拷贝，要实现cloneable接口，并在clone方法，把该对象引用的其他对象也clone，而且被引用的对象也要实现cloneable接口并实现clone方法</p>
<h3 id="14、方法重写和方法重载"><a href="#14、方法重写和方法重载" class="headerlink" title="14、方法重写和方法重载"></a>14、方法重写和方法重载</h3><p>​    方法重写：<br>​        方法重写的参数列表和返回类型要求一致<br>​        构造方法不能重写，final声明的方法不能被重写<br>​        访问权限不能比父类更低<br>​        不能比父类抛出更广泛的异常<br>​    方法重载<br>​        方法名一致，参数列表参数的顺序、返回类型、个数不同。<br>​        可以抛出更多的异常、有不同的修饰符</p>
<h3 id="15、Integer和Int的区别，封装类的作用"><a href="#15、Integer和Int的区别，封装类的作用" class="headerlink" title="15、Integer和Int的区别，封装类的作用"></a>15、Integer和Int的区别，封装类的作用</h3><p>​    1、Integer是int的封装类，int是基本数据类型<br>​    2、Integer是类，默认值是null，int是基本数据类型，默认值是0<br>​    3、Integer表示对象，是一个引用指向这个对象，而int是直接存储值<br>​    封装类可以进行各种数据类型之间转换,提供了多个与整数相关的操作方法。</p>
<h3 id="16、for循环和foreach循环的区别"><a href="#16、for循环和foreach循环的区别" class="headerlink" title="16、for循环和foreach循环的区别"></a>16、for循环和foreach循环的区别</h3><p>​    在固定长度或者长度不需要计算时，for循环的效率高于foreach循环<br>​    在不确定长度或者计算长度有损性能的时候用foreach循环</p>
<h3 id="17、迭代器和for循环的区别"><a href="#17、迭代器和for循环的区别" class="headerlink" title="17、迭代器和for循环的区别"></a>17、迭代器和for循环的区别</h3><p>​    迭代器的写法：<br>​        iterator it = set.iterator();<br>​        while(it.hasNext()){<br>​            system.out.println(it.next());<br>​        }<br>​    迭代器只能从头开始遍历、但是可以边遍历边删除<br>​    for循环可以指定位置遍历，性能最高，遍历的过程中不能删除</p>
<h3 id="18、Math函数"><a href="#18、Math函数" class="headerlink" title="18、Math函数"></a>18、Math函数</h3><p>​    Math.round(11.5)=12;Math.round(-11.5)=-11(四舍五入)<br>​    Math.ceil(11.5)=12;Math.ceil(-11.5)=-11(向上取整)<br>​    Math.floor(11.5)=11;Math.floor(-11.5)=-12(向下取整)</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="1-JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享"><a href="#1-JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享" class="headerlink" title="1.JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享"></a>1.JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享</h3><p>​    栈区存放基本数据类型、对象的引用，函数调用的现场保留<br>​    堆区存放new（）和构造器创建的对象<br>​    方法区存放常量池和static变量<br>​    只有堆内存的数据是线程共享的</p>
<h3 id="2、四种会话跟踪技术"><a href="#2、四种会话跟踪技术" class="headerlink" title="2、四种会话跟踪技术"></a>2、四种会话跟踪技术</h3><p>​    隐藏表单域<br>​    URL重写<br>​    Cookie<br>​    Session</p>
<h3 id="3-现有一个preson类，有3个属性："><a href="#3-现有一个preson类，有3个属性：" class="headerlink" title="3.现有一个preson类，有3个属性："></a>3.现有一个preson类，有3个属性：</h3><p>​     public class Preson (private String name; private int age;private String sex;}<br>​     请重写此类equal方法，当name和age都一样时，对象相等。<br>​     首先重写hashcode方法<br>​         public int hashcode（）{<br>​            return this.name.hashcode()+this.age*15//使不同的对象有不同的id<br>​         }<br>​      其次重写equal方法<br>​          public boolean equal（Object obj){<br>​              if(this==obj){<br>​                  return true;<br>​              }<br>​              if(!(obj istanceof Student)){<br>​                  return false;<br>​              }<br>​              Student s = (Student) obj;<br>​              return this.name.equals(s.name)&amp;&amp;this.age==s.age<br>​          }</p>
<h3 id="4-描述一下双亲委派机制。"><a href="#4-描述一下双亲委派机制。" class="headerlink" title="4.描述一下双亲委派机制。"></a>4.描述一下双亲委派机制。</h3><p>​    根类加载器 jre/lib<br>​    扩展类加载器 jre/lib/ext<br>​    应用程序类加载器 classpath<br>​    自定义类加载器</p>
<h3 id="5、Ajax的基本原理"><a href="#5、Ajax的基本原理" class="headerlink" title="5、Ajax的基本原理"></a>5、Ajax的基本原理</h3><p>​    通过XmlHttpRequest对象来向服务器发异步请求、从服务器获得数据，然后使用js操作dom而更新页面</p>
<h3 id="6、assert断言"><a href="#6、assert断言" class="headerlink" title="6、assert断言"></a>6、assert断言</h3><p>​    assert是一种调试方式，用于对程序的调试和执行结构的判断，用于保证程序最基本、关键的正确性。对boolean表达式进行检查，如果true程序正确</p>
<h3 id="7、xml定义文档的方式，解析xml的的方式"><a href="#7、xml定义文档的方式，解析xml的的方式" class="headerlink" title="7、xml定义文档的方式，解析xml的的方式"></a>7、xml定义文档的方式，解析xml的的方式</h3><p>​    定义文档的方式：dtd、schema<br>​    解析xml的方式：DOM、SAX<br>​        DOM:可以进行CRUD操作，但是占内存<br>​        SAX：不占内存。但是只能进行读操作</p>
<h3 id="8、谈谈反射"><a href="#8、谈谈反射" class="headerlink" title="8、谈谈反射"></a>8、谈谈反射</h3><p>​    反射是通过获得类的字节码文件来得到类中的属性和方法，再说一下三种获得字节码文件的方式：class.forname()、类名.class、对象.getclass</p>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><h3 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h3><pre><code>参数化类型，只有在调用时才确认类型</code></pre><h3 id="9、多线程"><a href="#9、多线程" class="headerlink" title="9、多线程"></a>9、多线程</h3><p>​    1、解释线程<br>​    2、线程的生命周期<br>​    3、实现多线程的方法</p>
<h3 id="13、having和where的区别"><a href="#13、having和where的区别" class="headerlink" title="13、having和where的区别"></a>13、having和where的区别</h3><p>​    1、having一般跟在分组条件前面，where一般在分组条件后面<br>​    2、having后面可以跟聚合函数，where后面不可以<br>14、死锁<br>​    两个及两个以上的线程在执行期间、由于竞争资源或者彼此通信而造成一种阻塞的现象。<br>​    四个必要条件：<br>​        互斥条件</p>
<h3 id="1、业务权限问题"><a href="#1、业务权限问题" class="headerlink" title="1、业务权限问题"></a>1、业务权限问题</h3><p>​    1、你的权限是怎么做的<br>​    2、有几张表，拿几张表，表的关系是如何的<br>​    3、如何根据角色 查询当前角色具有的权限 </p>
<h3 id="2、-Autowire与-Resource的区别"><a href="#2、-Autowire与-Resource的区别" class="headerlink" title="2、@Autowire与@Resource的区别"></a>2、@Autowire与@Resource的区别</h3><p>​    @Autowire<br>​        是spring提供的<br>​        默认按照类型进行装配<br>​            如果发现满足这个类型有两个及以上，就会按照名称装配<br>​            如果也没有发现对应名称，就直接报错<br>​            @Qualifier(“userinfoServiceImpl”)  指定我是用那个类的名称作为当前对象的注入。 有两个以上采用。<br>​    @Resource<br>​        是jdk提供的<br>​        默认按照名称进行装配<br>​            装配失败，会按照类型进行装配</p>
<h3 id="3、java获取方法的参数名"><a href="#3、java获取方法的参数名" class="headerlink" title="3、java获取方法的参数名"></a>3、java获取方法的参数名</h3><p>​    <!--Java无法通过反射获取方法的参数名--><br>​    1、JavaAssiat 能够对字节码进行编程<br>​    2、Spring提供LocalVariableTableParameterNameDiscoverer，能够读取字节码得到参数名称<br>​    3、jdk1.8设置之后也可以读取到参数名称</p>
<h3 id="4、两表联查的方式"><a href="#4、两表联查的方式" class="headerlink" title="4、两表联查的方式"></a>4、两表联查的方式</h3><p>​    1、嵌套结果<br>​        优点：<br>​            查询的sql语句只有一条<br>​        缺点：<br>​            字段描述多遍，不利于修改<br>​            根本无法递归<br>​    2、嵌套查询<br>​        优点：<br>​            可以实现递归<br>​            字段描述完全可以重用<br>​        缺点：<br>​            查询的sql语句有N条，会造成1+N的问题<br>​            如果使用二级缓存，可以解决1+N的问题</p>
<h3 id="5、关于mysql三大范式的冲突"><a href="#5、关于mysql三大范式的冲突" class="headerlink" title="5、关于mysql三大范式的冲突"></a>5、关于mysql三大范式的冲突</h3><p>​    1、所有字段尽量赋初始值，不要有字段为null，虽然和三大范式冲突，但是可以提高查询效率<br>​    select * from table where id is not null<br>​    这个查询语句会引发全表扫描，不会命中索引<br>​    2、不只通过外键传递依赖<br>​        A；uid uname<br>​        B:cid cname uid （经常uname）<br>​            只要满足uanme永远唯一，且永远不会改变<br>​    3、主键无关性</p>
<h3 id="6、mysql索引"><a href="#6、mysql索引" class="headerlink" title="6、mysql索引"></a>6、mysql索引</h3><p>​    索引可以提高程序的查询效率，<br>​    在mysql中的Innodb引擎只支持一种索引，数据结构<strong>B+树</strong>索引，当你更改数据的时候，只会引发当前节点和相邻节点的引用关系的改变，根本不会导致整个索引表的重排。<strong>所以大量频繁维护的表，适合建立索引</strong><br>​    但是B+树索引，适合建立在高基数（重复值较少）的列上<br>​    不适合建立低基数（sex）列上。低基数应该用BitMap位图索引（Mysql没有该引擎）</p>
<h3 id="7、var和let的作用范围"><a href="#7、var和let的作用范围" class="headerlink" title="7、var和let的作用范围"></a>7、var和let的作用范围</h3><p>​    var的作用域范围是函数体，声明变量一定要加var<br>​    不加var的变量是全局变量<br>​    在函数内的判断中加var，var在整个函数中有效<br>​    let（ES6）的作用域范围是{}内部<br>​    const与了let的作用域是一样的，不同的是const变量一旦被赋值，就不能再改变<br>​    但是这并不意味着使用const声明的变量本身不可变，只是说它不可被再次赋值了</p>
<h3 id="8、缓存的适用性及不适用性"><a href="#8、缓存的适用性及不适用性" class="headerlink" title="8、缓存的适用性及不适用性"></a>8、缓存的适用性及不适用性</h3><p>​    1：金融性数据禁止使用缓存。<br>​    2：关键性数据禁止使用缓存。<br>​    3：私有数据禁止使用缓存。Userinfo<br>​    4：维护过于频繁的数据不要使用二级缓存。</p>
<h3 id="9、MyBatis和Hibernat二级缓存的区别"><a href="#9、MyBatis和Hibernat二级缓存的区别" class="headerlink" title="9、MyBatis和Hibernat二级缓存的区别"></a>9、MyBatis和Hibernat二级缓存的区别</h3><p>​    Hibernate：<br>​        Hibernate的二级缓存是对对象而言<br>​        内部维系了一个Map&lt;key,Value&gt;<br>​            session.get(1);<br>​            session.get(1);<br>​            能够命中缓存<br>​            ===============================================<br>​            List list = session.createQuery(“from userinfo”).list();//即时加载<br>​            session.get(1);<br>​            能够命中：第一句话已经把查出来所有数据，都放到二级缓存中去了<br>​            ================================================<br>​            List list = session.createQuery(“from userinfo”).list();//即时加载<br>​            List list = session.createQuery(“from userinfo”).list();<br>​            不会命中缓存,害怕有数据的更改。如果你非要命中缓存，请你使用查询缓存。<br>​            =================================================<br>​            List list = session.createQuery(“from userinfo”).list();//即时加载<br>​            query.setCacheAble(true);<br>​            List list = session.createQuery(“from userinfo”).list();<br>​            query.setCacheAble(true);<br>​            xml在开启查询缓存，才能命中。<br>​        readonly:[true|false]<br>​            是否只读，能否可以修改<br>​    Mybatis<br>​        Mybatis的二级缓存是对NameSpace而言<br>​        Map（key（NameSpace+SQL））<br>​            mapper.findAll();<br>​            mapper.findById();//不会命中缓存<br>​            ===============================================<br>​            对这个命名空间下的任何的数据操作(insert,update,delete)，都会引发当前整个<br>​            NameSpace下的所有的缓存失效。<br>​            Bug:你更改A表，没有清空B表的缓存。<br>​                ThreadA: 查A表，关联了B表。 它的NameSpace是A。放入Cache。<br>​                       潘峰—–》如花<br>​                ThreadB: 修改B。NameSpace为B的缓存全部失效，重新查询。<br>​                       把如花改成了高鹏<br>​                此时：ThreadA里面的B是谁？<br>​                       老潘认为他的女朋友是谁？<br>​            解决方案：<br>​                1：cache的超时<br>​                2：用Redis更改A的时候，也清空B。<br>​        <!-- Size 缓存的的大小  flushInterval隔多久数据同步一次 LRU最近最少，FIFO先进先出--><br>​        <cache size="5000" flushInterval="5000" eviction="LRU" readOnly="true"></cache><br>​        readonly[true|false]:<br>​            readonly:true<br>​                给所有用户返回同一个对象<br>​            readonly：false<br>​                给所有用户返回对象的克隆clone</p>
<h3 id="10、三种Mybatis缓存可能发生的问题"><a href="#10、三种Mybatis缓存可能发生的问题" class="headerlink" title="10、三种Mybatis缓存可能发生的问题"></a>10、三种Mybatis缓存可能发生的问题</h3><p>​    <strong>1、缓存穿透</strong><br>​        假如我请求一个不存在的值。比如id=-1.<br>​        意味着先查询数据库，数据库没有找到。返回null。<br>​        如果再来一遍呢？<br>​            默认仍然先查数据库，数据库没有找到。返回null。<br>​            可以使劲查询，至到把服务器 down。<br>​        Mybatis3.5.1已经修复了这个问题。<br>​            解决问题的方案：<br>​                1：查不到，Map(key,null)<br>​                2: 布隆过滤器。<br>​    <strong>2、缓存击穿</strong><br>​        缓存中没有这个数据，但是数据库中是有这个数据的。<br>​        但是同一时间的并发量是巨大的（高并发）。所有的线程都没有从缓存<br>​        中命中数据，但同时所有的线程，都从数据库中开始查询数据。这一瞬间，就有可能<br>​        导致服务器的坍塌。<br>​        解决方案：<br>​            1：上同步锁。<br>​            2：上Redis。<br>​    <strong>3、缓存雪崩</strong><br>​        缓存都有一个超时时间，如果你走默认的，所有的超时时间都是一致的。<br>​        在达到某一个时间点的时候，所有的缓存全部失效。<br>​        整个项目的所有线程（用户），都会命中缓存失效，全部重新查询数据库。<br>​        有可能导致整个系统全部宕机。<br>​        解决方案：：<br>​            1：设置超时时间不一致，甚至随机数<br>​            2：上Redis</p>
<h3 id="11、Lambda表达式"><a href="#11、Lambda表达式" class="headerlink" title="11、Lambda表达式"></a>11、Lambda表达式</h3><p>​    作用：简洁代码<br>​    前提：内部类中的方法只有一个<br>​    <!--匿名内部类--><br>​    comparator<Integer> cpt = new Comparator<Integer>(){<br>​        @Override<br>​        public int compare(Integer x,Integer y){<br>​            return Integer.comparator(x,y);<br>​        }<br>​    }<br>​    <!--Lambda表达式--><br>​    Comparator<Integer> cpt2 = (x,y) -&gt; Integer.comparator(x,y);</p>
<h3 id="17、为什么返回类型不能区分重载"><a href="#17、为什么返回类型不能区分重载" class="headerlink" title="17、为什么返回类型不能区分重载"></a>17、为什么返回类型不能区分重载</h3><p>​    调用时不能确定指定类型信息，编译器不知道调用那个函数</p>
<h3 id="19、servlet的生命周期"><a href="#19、servlet的生命周期" class="headerlink" title="19、servlet的生命周期"></a>19、servlet的生命周期</h3><p>​    a.在客户端第一次请求servlet的时候，servlet容器（tomcat）就会实例化servlet。该servlet的实例会一直驻留在内存中，以便响应后续请求。<br>​    b. 在servlet被实例化之后，servlet容器就调用servlet的init方法，该方法在整个servlet生命周期之间只执行一次<br>​    c. 在servlet每次接收到请求的时候，servlet容器都会调用servlet的service方法该方法接收请求，并做出响应。<br>​    d. 在web应用即将被卸载的时候，servlet容器就会调用servlet的destory方法，该方法在整个servlet生命周期之间只执行一次<br>​    补充：如果在配置servlet的时候，添加了<load-on-startup>1</load-on-startup>，那么servlet将会在web应用被部署的时候，就被servlet容器所实例化！</p>
<h3 id="20、静态包含和动态包含的区别"><a href="#20、静态包含和动态包含的区别" class="headerlink" title="20、静态包含和动态包含的区别"></a>20、静态包含和动态包含的区别</h3><p>​    静态包含&lt;%@include file=”xxx.jsp”%&gt;是jsp的编译指令，动态包含&lt;jsp:include page=”xxx.jsp”&gt;是动作指令<br>​    静态包含是发生在jsp转化为servlet时期，动态包含发生在编译时期，<br>​    静态包含只会产生一个class文件，动态包含可以产生多个<br>​    使用静态包含，包含页面和被包含页面的request对象为同一对象，因为静态包含只是将被包含的页面的内容复制到包含的页面中去；而动态包含包含页面和被包含页面不是同一个页面，被包含的页面的request对象可以取到的参数范围要相对大些，不仅可以取到传递到包含页面的参数，同样也能取得在包含页面向下传递的参数 </p>
<h3 id="21、多线程有几种实现方案，分别是哪几种？"><a href="#21、多线程有几种实现方案，分别是哪几种？" class="headerlink" title="21、多线程有几种实现方案，分别是哪几种？"></a>21、多线程有几种实现方案，分别是哪几种？</h3><p>​    两种，继承Thread类，实现Runnable接口</p>
<h3 id="22、同步有几种方式，分别是什么"><a href="#22、同步有几种方式，分别是什么" class="headerlink" title="22、同步有几种方式，分别是什么?"></a>22、同步有几种方式，分别是什么?</h3><p>​    两种，同步代码块，同步方法</p>
<h3 id="23、启动一个线程是run-还是start-，他们的区别？"><a href="#23、启动一个线程是run-还是start-，他们的区别？" class="headerlink" title="23、启动一个线程是run()还是start()，他们的区别？"></a>23、启动一个线程是run()还是start()，他们的区别？</h3><p>​    run():封装了被线程执行的代码，直接调用仅仅是普通方法的调用<br>​    start():启动线程，并由JVM自动调用run()方法</p>
<h3 id="24、sleep-和wait-方法的区别"><a href="#24、sleep-和wait-方法的区别" class="headerlink" title="24、sleep()和wait()方法的区别"></a>24、sleep()和wait()方法的区别</h3><p>​    sleep():不释放锁<br>​    wait():释放锁</p>
<h3 id="25、为什么wait-、notify-、notifyAll-等方法都定义在Object类中"><a href="#25、为什么wait-、notify-、notifyAll-等方法都定义在Object类中" class="headerlink" title="25、为什么wait()、notify()、notifyAll()等方法都定义在Object类中"></a>25、为什么wait()、notify()、notifyAll()等方法都定义在Object类中</h3><p>​    因为这些方法的调用时、是依赖于锁对象，而同步代码块的锁对象是任意锁。<br>​    而object代码任意的对象，所以，定义在这里面</p>
<h3 id="26、线程的生命周期图"><a href="#26、线程的生命周期图" class="headerlink" title="26、线程的生命周期图"></a>26、线程的生命周期图</h3><p>​    新建——就绪——运行——阻塞——死亡</p>
<h3 id="27、Session和Cookie的区别"><a href="#27、Session和Cookie的区别" class="headerlink" title="27、Session和Cookie的区别"></a>27、Session和Cookie的区别</h3><p>​        1、Session的数据存放在服务器端，Cookie的数据存放在客户端<br>​        2、Session数据没有大小限制，Cookie有<br>​        3、Session安全，Cookie不安全<br>​        4、Session可以存放任何java数据，而Cookie只能存放String字符串</p>
<h3 id="28、forward跳转和redirect重定向的区别"><a href="#28、forward跳转和redirect重定向的区别" class="headerlink" title="28、forward跳转和redirect重定向的区别"></a>28、forward跳转和redirect重定向的区别</h3><p>​    forward是服务器内部跳转，可以带参数<br>​    redirect是请求二次服务器，url地址不同，不可以带参数<br>10、mysql数据锁<br>​    锁的作用：在数据库并发操作下，保证数据的完整性和一致性<br>11、js如何向数组添加元素<br>​    let myArray=[11,22,33];<br>​    console.log(‘原数组：’,myArray);<br>​    myArray.push(44,55);<br>​    console.log(‘用push在数组后面插入元素：’,myArray);<br>​    myArray.unshift(66,77);<br>​    console.log(‘用unshift在数组前面插入元素：’,myArray);<br>​    myArray.splice(2,0,’肾虚少年’);<br>​    console.log(‘用splice在数组指定位置插入元素：’,myArray);<br>​        </p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>​    1、描述SpringMVC请求处理与响应流程，以及核心组件<br>​        核心组件：<br>​            前端控制器<br>​            映射器处理器<br>​            适配器处理器<br>​            视图解析器<br>​    2、一个请求到SpringMVC，首先必须经过前端控制器DispatcherServlet吗？<br>​        可以配置的。<br>​        在web.xml文件中配置如下信息：<br>​        <servlet-mapping><br>​            <servlet-name>default</servlet-name><br>​            <url-pattern><em>.html</url-pattern><br>​        </servlet-mapping><br>​        以上配置可以实现</em>.html文件不经过DispatcherServlet，可以直接找到*.html资源<br>​    3、springboot比springmvc的优势在哪里<br>​        springmvc是基于spring的一个mvc框架，<br>​    优势是：实现了自动装配，降低项目搭建的困难度<br>​    4.SpringMVC常用注解和作用<br>​        @RequsetMapper(“”)：url路径<br>​        @Controller():表明这是控制器<br>​        @RequsetBody:接收请求的json数据，将json数据转换为Java对象<br>​        @ResponseBody:将返回对象转换json数据响应客户<br>​        @RequestParam:形参名和请求参数名一致<br>​    5、springmvc controller返回值类型，具体作用<br>​        ModelAndView<br>​        String<br>​        void<br>​    6、谈一下springmvc<br>​        springmvc是spring模式的web层框架，由四大核心组件构成，陈述原理</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><pre><code>1.Mybatis怎么配一对一和多对多
    resultMap/resulttype
    association/collection
    javatype/oftype
2、介绍一下MyBatis?
    Mybatis是一个优秀的持久层框架，它封装了jdbc操作数据库的过程，只需要写sql语句，
    mybatis通过读取配置配置文件，创建SqlSessionFactory会话工厂，然后在创建Sqlsession，通过Sqlsession来操作数据库，
    SqlSession是通过底层的Executor执行器接口来操作数据库，Exceutor执行器处理的Sql信息是封装到一个底层对象的MappedStatement中，
4、MyBatis生成的xml都有哪些标签？
    requestmap、select、result、insert、update、delete
5、Mybatis 返回类型用什么指定
    resultType指定输出的Java类型
11、Mybatis 传入参数 类型用什么指定
    parameterType指定输入参数的java类型
6、resultMap和resultType的区别？
    resultType：查询的列名和映射的pojo属性名完全一致
    resultMap：查询的列名和映射的pojo属性名可以不一致
7、谈谈Mybatis的缓存？
    一级缓存：
        存入SqlSession中，数据结构是HashMap，当SqlSession消失时，mybatis的一级缓存也会消失
        当调用SqlSession的修改、添加、删除，
    二级缓存：
        Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存
        第一步在主配置文件中开启二级缓存
            &lt;settings&gt;
                &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;
            &lt;/settings&gt;
        第二步在映射配置文件中
            &lt;cache /&gt;
        第三步在select标签中使用属性usecache=&quot;true&quot;
8、redis替代mybatis的二级缓存
9、数据库查询到一个空id或者null，mybatis如何判断的？
10、mybatis xml namespace里面写的是啥，什么作用。
    mapper接口的类路径
13、如何查询最后一条数据：mybatis
15、mybatis的延迟加载是什么，怎么用
    只想获取某个字段，就用延迟加载，只能进行属性级别的延迟加载
    首先在主配置文件打开延迟加载
    &lt;settings&gt;
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&gt;
        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;&gt;
    &lt;/settings&gt;
    映射配置文件中
    &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;com.woniuxy.l_lazyload.EmpMapper。findSomeByDid&quot; column=&quot;did&quot;&gt;
16、mybatis的主配置文件配置了什么？
    数据源、事务、别名、映射配置文件的位置
17、#{}和${}的区别
    #{}在sql语句中有单引号，${}没有单引号
    #{}底层是preparedStatment，不会引发sql注入，${}底层是Statment，会引发sql注入
18、mapper的开发规范
    1、mapper接口的全名与mapper映射文件的namespace的值相同
    2、mapper接口的方法名与mapper映射文件的id的值相同
    3、mapper接口的方法参数与mapper映射文件的parameterType的值相同
    4、mapper接口的返回类型与mapper映射文件的resultType的值相同
19、mybatis mapper绑定的原理
    Mybatis会自动的为mapper接口生成动态代理实现类。</code></pre><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>​    1、谈一下springBoot<br>​        我觉的spingboot是一个整合工具，它可以自动装配，降低了搭建环境的难度<br>​        内置web服务器<br>​        简化了maven配置<br>​        无需配置xml，导入jar包即可<br>​    2.Springboot自动装配原理<br>​        @SpringBootApplication注解中的@EnableAutoConfigure中的@Import中的selectImports方法返回了一个全类名的数组，全类名来源于spring-boot-autoConfigure中的spring.factories,</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>​    1、谈谈spring<br>​        spring是为了解决企业应用开发的复杂性而创建的，是一个轻量级的控制反转和面向切面的容器框架<br>​    2、Spring在选择用JDK动态代理还是CGLiB动态代理的依据和区别<br>​        jdk实现了接口的类，是用反射生成一个匿名子类，<br>​        cglib没有实现接口的类，使用asm开源包，将被代理对象加载，通过修改字节码文件生成子类<br>​    3、spring aop实现原理<br>​        动态代理<br>​    4、spring template<br>​        是一种操作数据库的技术、对jdbc做了封装，简化了数据库的操作，能够把数据对象映射成实体类。<br>​    5、spring注解<br>​        @Component<br>​        @Repository<br>​        @Service<br>​        @Controller<br>​        @Autowired<br>​        @Resource<br>​    6、spring的注入有几种<br>​        构造方法<br>​        setter方法<br>​        p命名空间注入<br>​        集合注入<br>​        基于注解的注入<br>​    7、spring默认装配吗<br>​        不默认装配<br>​    8、Spring和SpringBoot的区别<br>​        springboot是spring的拓展，使得开发和部署更加方便<br>​        无需配置复杂的xml，只需导入相关jar包，<br>​        内嵌了Web服务器<br>​        提供POM、简化了Maven配置<br>​    9、Bean的配置<br>​        全类名的反射<br>​        静态工厂<br>​        实例工厂<br>​    10、spring的事务<br>​        事务的特性<br>​            原子性<br>​            一致性<br>​            隔离性<br>​            持久性<br>​        隔离级别<br>​            读未提交<br>​            读已提交<br>​            可重复读<br>​            串行<br>​        传播行为：<br>​            <strong>1、PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>​            2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘<br>​            3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>​            <strong>4、PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。<br>​            5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>​            6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>​            <strong>7、PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。<br>​    11、静态代理和动态代理的区别<br>​        静态代理只能代理一个类，动态代理可以代理一个接口下的多个接口类<br>​        静态代理事先就知道要代理那个类，动态代理在运行时才知道<br>​    12、jdk动态代理和cglib动态代理的区别<br>​        jdk是通过反射机制生成一个实现接口的匿名子类<br>​        cglib是通过asm开源包，将被代理对象类加载进来，通过修改字节码文件生成子类<br>​        实现了接口，就可以用jdk动态代理，也可以强制使用cglib<br>​        如果没有实现接口，就必须使用cglib<br>​    13、spring的好处<br>​        1、方便解耦，简化开发，<br>​        2、AOP编程的支持<br>​        3、声明式事务的支持<br>​        4、spring对junit4支持，方便程序测试<br>​        5、方便集成各种优秀框架</p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/01/Java/" rel="prev" title="Java">
                  Java <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、JDK和JRE有什么区别"><span class="nav-number">1.</span> <span class="nav-text">1、JDK和JRE有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、-和equals的区别是什么"><span class="nav-number">2.</span> <span class="nav-text">2、==和equals的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、hashcode和equal"><span class="nav-number">3.</span> <span class="nav-text">3、hashcode和equal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、final关键字"><span class="nav-number">4.</span> <span class="nav-text">4、final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、一个“-java”源文件是否可以包括多个类（不是内部类）？有什么限制？"><span class="nav-number">5.</span> <span class="nav-text">5、一个“.java”源文件是否可以包括多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、-amp-与-amp-amp-的区别"><span class="nav-number">6.</span> <span class="nav-text">6、&amp;与&amp;&amp;的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、在Java中如何跳出当前的多重嵌套循环？"><span class="nav-number">7.</span> <span class="nav-text">7、在Java中如何跳出当前的多重嵌套循环？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、switch语句可以作用在byte、short、char、int、枚举、String"><span class="nav-number">8.</span> <span class="nav-text">8、switch语句可以作用在byte、short、char、int、枚举、String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、-运算符，java编译器会对它进行类型转换"><span class="nav-number">9.</span> <span class="nav-text">9、+=运算符，java编译器会对它进行类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、char类型可以存储一个中文汉字"><span class="nav-number">10.</span> <span class="nav-text">10、char类型可以存储一个中文汉字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、静态变量和实例变量的区别"><span class="nav-number">11.</span> <span class="nav-text">11、静态变量和实例变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、面向对象的三大特点"><span class="nav-number">12.</span> <span class="nav-text">12、面向对象的三大特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、clone的相关知识点"><span class="nav-number">13.</span> <span class="nav-text">13、clone的相关知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、方法重写和方法重载"><span class="nav-number">14.</span> <span class="nav-text">14、方法重写和方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、Integer和Int的区别，封装类的作用"><span class="nav-number">15.</span> <span class="nav-text">15、Integer和Int的区别，封装类的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、for循环和foreach循环的区别"><span class="nav-number">16.</span> <span class="nav-text">16、for循环和foreach循环的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、迭代器和for循环的区别"><span class="nav-number">17.</span> <span class="nav-text">17、迭代器和for循环的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、Math函数"><span class="nav-number">18.</span> <span class="nav-text">18、Math函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number"></span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享"><span class="nav-number">1.</span> <span class="nav-text">1.JVM堆栈方法区放哪些数据，3个区域中那些数据是线程共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、四种会话跟踪技术"><span class="nav-number">2.</span> <span class="nav-text">2、四种会话跟踪技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-现有一个preson类，有3个属性："><span class="nav-number">3.</span> <span class="nav-text">3.现有一个preson类，有3个属性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-描述一下双亲委派机制。"><span class="nav-number">4.</span> <span class="nav-text">4.描述一下双亲委派机制。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、Ajax的基本原理"><span class="nav-number">5.</span> <span class="nav-text">5、Ajax的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、assert断言"><span class="nav-number">6.</span> <span class="nav-text">6、assert断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、xml定义文档的方式，解析xml的的方式"><span class="nav-number">7.</span> <span class="nav-text">7、xml定义文档的方式，解析xml的的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、谈谈反射"><span class="nav-number">8.</span> <span class="nav-text">8、谈谈反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解："><span class="nav-number">9.</span> <span class="nav-text">注解：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型："><span class="nav-number">10.</span> <span class="nav-text">泛型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、多线程"><span class="nav-number">11.</span> <span class="nav-text">9、多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、having和where的区别"><span class="nav-number">12.</span> <span class="nav-text">13、having和where的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1、业务权限问题"><span class="nav-number">13.</span> <span class="nav-text">1、业务权限问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、-Autowire与-Resource的区别"><span class="nav-number">14.</span> <span class="nav-text">2、@Autowire与@Resource的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、java获取方法的参数名"><span class="nav-number">15.</span> <span class="nav-text">3、java获取方法的参数名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、两表联查的方式"><span class="nav-number">16.</span> <span class="nav-text">4、两表联查的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、关于mysql三大范式的冲突"><span class="nav-number">17.</span> <span class="nav-text">5、关于mysql三大范式的冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、mysql索引"><span class="nav-number">18.</span> <span class="nav-text">6、mysql索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、var和let的作用范围"><span class="nav-number">19.</span> <span class="nav-text">7、var和let的作用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、缓存的适用性及不适用性"><span class="nav-number">20.</span> <span class="nav-text">8、缓存的适用性及不适用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、MyBatis和Hibernat二级缓存的区别"><span class="nav-number">21.</span> <span class="nav-text">9、MyBatis和Hibernat二级缓存的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、三种Mybatis缓存可能发生的问题"><span class="nav-number">22.</span> <span class="nav-text">10、三种Mybatis缓存可能发生的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、Lambda表达式"><span class="nav-number">23.</span> <span class="nav-text">11、Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、为什么返回类型不能区分重载"><span class="nav-number">24.</span> <span class="nav-text">17、为什么返回类型不能区分重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、servlet的生命周期"><span class="nav-number">25.</span> <span class="nav-text">19、servlet的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、静态包含和动态包含的区别"><span class="nav-number">26.</span> <span class="nav-text">20、静态包含和动态包含的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、多线程有几种实现方案，分别是哪几种？"><span class="nav-number">27.</span> <span class="nav-text">21、多线程有几种实现方案，分别是哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、同步有几种方式，分别是什么"><span class="nav-number">28.</span> <span class="nav-text">22、同步有几种方式，分别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23、启动一个线程是run-还是start-，他们的区别？"><span class="nav-number">29.</span> <span class="nav-text">23、启动一个线程是run()还是start()，他们的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24、sleep-和wait-方法的区别"><span class="nav-number">30.</span> <span class="nav-text">24、sleep()和wait()方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25、为什么wait-、notify-、notifyAll-等方法都定义在Object类中"><span class="nav-number">31.</span> <span class="nav-text">25、为什么wait()、notify()、notifyAll()等方法都定义在Object类中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26、线程的生命周期图"><span class="nav-number">32.</span> <span class="nav-text">26、线程的生命周期图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27、Session和Cookie的区别"><span class="nav-number">33.</span> <span class="nav-text">27、Session和Cookie的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28、forward跳转和redirect重定向的区别"><span class="nav-number">34.</span> <span class="nav-text">28、forward跳转和redirect重定向的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC"><span class="nav-number"></span> <span class="nav-text">SpringMVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis"><span class="nav-number"></span> <span class="nav-text">Mybatis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot"><span class="nav-number"></span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number"></span> <span class="nav-text">Spring</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="老寒腿青年"
    src="/images/mj.jpg">
  <p class="site-author-name" itemprop="name">老寒腿青年</p>
  <div class="site-description" itemprop="description">莫向外求</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老寒腿青年</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.3
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
